{"version":3,"sources":["C:/Users/javia/lax-squad/admin-portal/node_modules/@angular/fire/fesm2015/angular-fire.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuXC,6MAKC;;;;;;;;;;;;;kCAIA","file":"angular-fire.js","sourcesContent":["import { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport { apps, initializeApp, registerVersion } from 'firebase/app';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction noop() { }\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n    /**\n     * @param {?} zone\n     * @param {?=} delegate\n     */\n    constructor(zone, delegate = queueScheduler) {\n        this.zone = zone;\n        this.delegate = delegate;\n    }\n    /**\n     * @return {?}\n     */\n    now() {\n        return this.delegate.now();\n    }\n    /**\n     * @param {?} work\n     * @param {?=} delay\n     * @param {?=} state\n     * @return {?}\n     */\n    schedule(work, delay, state) {\n        /** @type {?} */\n        const targetZone = this.zone;\n        // Wrap the specified work function to make sure that if nested scheduling takes place the\n        // work is executed in the correct zone\n        /** @type {?} */\n        const workInZone = (/**\n         * @this {?}\n         * @param {?} state\n         * @return {?}\n         */\n        function (state) {\n            targetZone.runGuarded((/**\n             * @return {?}\n             */\n            () => {\n                work.apply(this, [state]);\n            }));\n        })\n        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n        ;\n        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n        return this.delegate.schedule(workInZone, delay, state);\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ɵZoneScheduler.prototype.zone;\n    /**\n     * @type {?}\n     * @private\n     */\n    ɵZoneScheduler.prototype.delegate;\n}\n/**\n * @template T\n */\nclass ɵBlockUntilFirstOperator {\n    /**\n     * @param {?} zone\n     */\n    constructor(zone) {\n        this.zone = zone;\n        this.task = null;\n    }\n    /**\n     * @param {?} subscriber\n     * @param {?} source\n     * @return {?}\n     */\n    call(subscriber, source) {\n        /** @type {?} */\n        const unscheduleTask = this.unscheduleTask.bind(this);\n        this.task = this.zone.run((/**\n         * @return {?}\n         */\n        () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));\n        return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    unscheduleTask() {\n        // maybe this is a race condition, invoke in a timeout\n        // hold for 10ms while I try to figure out what is going on    \n        setTimeout((/**\n         * @return {?}\n         */\n        () => {\n            if (this.task != null && this.task.state === 'scheduled') {\n                this.task.invoke();\n                this.task = null;\n            }\n        }), 10);\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ɵBlockUntilFirstOperator.prototype.task;\n    /**\n     * @type {?}\n     * @private\n     */\n    ɵBlockUntilFirstOperator.prototype.zone;\n}\nclass ɵAngularFireSchedulers {\n    /**\n     * @param {?} ngZone\n     */\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.outsideAngular = ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => new ɵZoneScheduler(Zone.current)));\n        this.insideAngular = ngZone.run((/**\n         * @return {?}\n         */\n        () => new ɵZoneScheduler(Zone.current, asyncScheduler)));\n    }\n}\nif (false) {\n    /** @type {?} */\n    ɵAngularFireSchedulers.prototype.outsideAngular;\n    /** @type {?} */\n    ɵAngularFireSchedulers.prototype.insideAngular;\n    /** @type {?} */\n    ɵAngularFireSchedulers.prototype.ngZone;\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n * @param {?} schedulers\n * @param {?} platformId\n * @return {?}\n */\nfunction ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\n    return (/**\n     * @template T\n     * @param {?} obs$\n     * @return {?}\n     */\n    function keepUnstableUntilFirst(obs$) {\n        obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n        return obs$.pipe(\n        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n        subscribeOn(schedulers.outsideAngular), \n        // Run operators inside the angular zone (e.g. side effects via tap())\n        observeOn(schedulers.insideAngular)\n        // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n        // share()\n        );\n    });\n}\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n/** @type {?} */\nconst noopFunctions = ['ngOnDestroy'];\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n/** @type {?} */\nconst ɵlazySDKProxy = (/**\n * @param {?} klass\n * @param {?} observable\n * @param {?} zone\n * @return {?}\n */\n(klass, observable, zone) => {\n    return new Proxy(klass, {\n        get: (/**\n         * @param {?} _\n         * @param {?} name\n         * @return {?}\n         */\n        (_, name) => zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            if (klass[name]) {\n                return klass[name];\n            }\n            if (noopFunctions.includes(name)) {\n                return (/**\n                 * @return {?}\n                 */\n                () => { });\n            }\n            /** @type {?} */\n            let promise = observable.toPromise().then((/**\n             * @param {?} mod\n             * @return {?}\n             */\n            mod => {\n                /** @type {?} */\n                const ret = mod && mod[name];\n                // TODO move to proper type guards\n                if (typeof ret == 'function') {\n                    return ret.bind(mod);\n                }\n                else if (ret && ret.then) {\n                    return ret.then((/**\n                     * @param {?} res\n                     * @return {?}\n                     */\n                    (res) => zone.run((/**\n                     * @return {?}\n                     */\n                    () => res))));\n                }\n                else {\n                    return zone.run((/**\n                     * @return {?}\n                     */\n                    () => ret));\n                }\n            }));\n            // recurse the proxy\n            return new Proxy((/**\n             * @return {?}\n             */\n            () => undefined), {\n                get: (/**\n                 * @param {?} _\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (_, name) => promise[name]),\n                // TODO handle callbacks as transparently as I can \n                apply: (/**\n                 * @param {?} self\n                 * @param {?} _\n                 * @param {?} args\n                 * @return {?}\n                 */\n                (self, _, args) => promise.then((/**\n                 * @param {?} it\n                 * @return {?}\n                 */\n                it => it && it(...args))))\n            });\n        })))\n    });\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction FirebaseOptions() { }\n;\n/**\n * @record\n */\nfunction FirebaseAppConfig() { }\n;\n/** @type {?} */\nconst FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\n/** @type {?} */\nconst FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');\n// Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\nclass FirebaseApp {\n}\nif (false) {\n    /** @type {?} */\n    FirebaseApp.prototype.name;\n    /** @type {?} */\n    FirebaseApp.prototype.options;\n    /** @type {?} */\n    FirebaseApp.prototype.analytics;\n    /** @type {?} */\n    FirebaseApp.prototype.auth;\n    /** @type {?} */\n    FirebaseApp.prototype.database;\n    /** @type {?} */\n    FirebaseApp.prototype.messaging;\n    /** @type {?} */\n    FirebaseApp.prototype.performance;\n    /** @type {?} */\n    FirebaseApp.prototype.storage;\n    /** @type {?} */\n    FirebaseApp.prototype.delete;\n    /** @type {?} */\n    FirebaseApp.prototype.firestore;\n    /** @type {?} */\n    FirebaseApp.prototype.functions;\n    /** @type {?} */\n    FirebaseApp.prototype.remoteConfig;\n}\n/** @type {?} */\nconst VERSION = new Version('6.0.0');\n/**\n * @param {?} options\n * @param {?} zone\n * @param {?=} nameOrConfig\n * @return {?}\n */\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n    /** @type {?} */\n    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n    /** @type {?} */\n    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n    config.name = config.name || name;\n    // Added any due to some inconsistency between @firebase/app and firebase types\n    /** @type {?} */\n    const existingApp = (/** @type {?} */ (apps.filter((/**\n     * @param {?} app\n     * @return {?}\n     */\n    app => app && app.name === config.name))[0]));\n    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n    return (/** @type {?} */ ((existingApp || zone.runOutsideAngular((/**\n     * @return {?}\n     */\n    () => initializeApp(options, (/** @type {?} */ (config))))))));\n}\n/** @type {?} */\nconst FirebaseAppProvider = {\n    provide: FirebaseApp,\n    useFactory: ɵfirebaseAppFactory,\n    deps: [\n        FIREBASE_OPTIONS,\n        NgZone,\n        [new Optional(), FIREBASE_APP_NAME]\n    ]\n};\nclass AngularFireModule {\n    /**\n     * @param {?} platformId\n     */\n    constructor(platformId) {\n        registerVersion('angularfire', VERSION.full, platformId.toString());\n        registerVersion('angular', VERSION$1.full);\n    }\n    /**\n     * @param {?} options\n     * @param {?=} nameOrConfig\n     * @return {?}\n     */\n    static initializeApp(options, nameOrConfig) {\n        return {\n            ngModule: AngularFireModule,\n            providers: [\n                { provide: FIREBASE_OPTIONS, useValue: options },\n                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }\n            ]\n        };\n    }\n}\nAngularFireModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [FirebaseAppProvider],\n            },] }\n];\n/** @nocollapse */\nAngularFireModule.ctorParameters = () => [\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy };\n"]}